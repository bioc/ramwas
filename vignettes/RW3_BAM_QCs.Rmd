---
title: "3. RaMWAS QC Measures for BAM files"
author: "Andrey A Shabalin"
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true # table of content true
vignette: >
  %\VignetteIndexEntry{3. QC Meansures for BAM files}
  %\VignetteEngine{knitr::rmarkdown}
---

# Loading and Saving RaMWAS objects

All RaMWAS objects are saved as text files,
filematrices, or .rds files.
The .rds files are saved and loaded with `saveRDS` and `readRDS` functions.

Below we load a sample QC file, which contains accumulated
QC measures from BAM files of a small project.

```{r global_options, include=FALSE}
#getwd()
#knitr::opts_chunk$set(fig.align="center", fig.retina=1)
knitr::opts_chunk$set(fig.retina=1)
library(ramwas)
```

```{r loadCgGset}
filename = system.file("extdata", "bigQC.rds", package = "ramwas")
qc = readRDS(filename)$qc
```

# Quality control measures

All QC measures are designed to be additive, in the sence that any QC
measure calculated for a concatination of two BAM files is equal to the
sum of the respective measure calculated for those BAMs separately.

Many QC measures can be visualized by calling `plot` function on them.
For some, single number summary is available via `qcmean` function.

The currently supported QC measures include the following:

## The number of BAM files

The sample QC file accumulates information from 42 BAMs.

```{r nbams}
cat("N BAMs:", qc$nbams)
```

## Total number of reads in the BAM file(s)

The 42 BAMs contain 2.46 billion reads.

```{r reads.total}
cat("Reads total:", qc$reads.total)
```

## Number of reads aligned to the reference genome

The number of aligned reads is only 2\% smaller, 2.42 billion.

```{r reads.aligned}
{
 cat("Reads aligned:", qc$reads.aligned, "\n")
 cat("This is ", qc$reads.aligned / qc$reads.total * 100,
     "% of all reads", sep="")
}
```

## Number of reads that passed minimum score filter

Almost of 2.2 billion reads passed the score threshold.

```{r reads.recorded}
{
 cat("Reads recorded:",qc$reads.recorded,"\n")
 cat("This is ", qc$reads.recorded / qc$reads.aligned * 100,
     "% of aligned reads", sep="")
}
```

## Number of recorded reads aligned to each strand

For this measure, `qcmean` returns the fraction of reads on forward strand.
Normally, the number of reads on forward and reverse strands is very close,
so `qcmean` should give a number close to `0.5`.

```{r frwrev}
{
 cat("Reads on forward strand:", qc$frwrev[1],"\n")
 cat("Reads on reverse strand:", qc$frwrev[2],"\n")
 cat("Fraction of reads on forward strand:", qcmean(qc$frwrev), "\n")
}
```


## Distribution of the alignment scores

The QC measures `bf.hist.score1` and `hist.score1` record the distribution of
the alignment scores before and after the filter.
The score is defined by the `scoretag` parameter.
While `hist.score1` contain the distribution for reads that passed the filter,
`bf.hist.score1` has the distribution for all reads.
The `qcmean` function for this QC measure returns
the average score for the respective group.
The first element of the vector `qc$hist.score1` contains the number of
reads with score of 0, the second with score of 1,
and so on. Negative scores (if any) are ignored.

```{r hist.score1, fig.width=8}
{
 cat("Average alignment score:", qcmean(qc$hist.score1), "\n")
 cat("Average alignment score, no filter:", qcmean(qc$bf.hist.score1), "\n")
 par(mfrow=c(1,2))
 plot(qc$hist.score1)
 plot(qc$bf.hist.score1)
}
```


## Distribution of the length of the aligned part of the reads

The length of the aligned part of a read is calculated from
the CIGAR string in the BAM file using `cigarWidthAlongQuerySpace` function.
As previously, the vector `hist.length.matched` has the distribution
for reads that passed the filter, `bf.hist.length.matched` -- for all reads.
The `qcmean` function for these QC measures returns the
average values.
The first element of the vector contains the number of
reads with 1 aligned basepair, the second with 2, and so on.

```{r hist.length.matched, fig.width=8}
{
 cat("Average aligned length:", qcmean(qc$hist.length.matched), "\n")
 cat("Average aligned length, no filter:",
     qcmean(qc$bf.hist.length.matched), "\n")
 par(mfrow = c(1,2))
 plot(qc$hist.length.matched)
 plot(qc$bf.hist.length.matched)
}
```


## Distribution of edit distance

This QC measure is calculated from the NM tag in BAM files.
It records the difference between the aligned part of the read 
and the reference genome as a result of base call errors or genetic variation.
The `qcmean` function for this QC measure returns
the average values.
The first element of the vector contains the number of reads
with 0 edit distance (perfect match), the second with edit distance 1,
and so on.

```{r hist.edit.dist1}
{
 cat("Average edit distance:", qcmean(qc$hist.edit.dist1), "\n")
 cat("Average edit distance, no filter:", qcmean(qc$bf.hist.edit.dist1), "\n")
 par(mfrow = c(1,2))
 plot(qc$hist.edit.dist1)
 plot(qc$bf.hist.edit.dist1)
}
```

## Number of reads after removal of duplicate reads

Duplicate-reads are reads that start at the same nucleotide positions. 
When sequencing a whole genome, duplicate-reads often arise from 
template preparation or amplification artifacts. 
In the context of sequencing an enriched genomic fraction, 
duplicate-reads are increasingly likely to occur because 
reads align to a much smaller fraction of the genome. 
RaMWAS allows the user to define a threshold for the number 
of reads starting at the same position and l
imits the read count to this threshold 
(implicitly assuming that an excess of 
reads are tagging the same clonal fragment). 

The  threshold is set by `maxrepeats` parameter
with the default being 3.


When there are mulptiple reads with the same start
position, we suspect them to be falsely duplicated.
QC metric `reads.recorded.no.repeats` records the
total number of reads after removal of duplicates and
`frwrev.no.repeats` 
shows how these reads are distributed across the forward and reverse strands. 

In our example, after removal of duplicates we are left with 90\% of the reads.
After removal of duplicate reads the fraction of reads on
forward strand got even closer to 0.5.

```{r reads.recorded.no.repeats}
{
 cat("Reads without duplicates:", qc$reads.recorded.no.repeats, "\n")
 cat("This is ", qc$reads.recorded.no.repeats / qc$reads.recorded * 100,
     "% of aligned reads", "\n", sep="")
 cat("Fraction of reads on forward strand (with    duplicates):",
     qcmean(qc$frwrev), "\n")
 cat("Fraction of reads on forward strand (without duplicates):",
     qcmean(qc$frwrev.no.repeats), "\n")
}
```

## Number of reads away from CpGs

MBD-seq detects CpG methylation, 
such that reads aligning to loci that are 
at least `maxfragmentsize` away from any CpG represent "noise".
These reads occur due to alignment errors or 
imperfect enrichment leading to sequencing of non-methylated fragments).

The QC measure `cnt.nonCpG.reads` contains the number of
non-CpG reads in it"s first element.

In our example there is less than 1\% of non-CpG reads,
which is consistent with low level of noise.

```{r cnt.nonCpG.reads}
{
 cat("Non-CpG reads:", qc$cnt.nonCpG.reads[1], "\n")
 cat("This is ", qcmean(qc$cnt.nonCpG.reads)*100, "% of recorded reads", sep="")
}
```

## Average coverage of CpGs and non-CpGs

Another measure of success of enrichment is calculated as follows.
We calculate average coverage of all CpGs and the
average coverage at a set of locations away from CpGs (so-called non-CpGs).
The ratio gives us a lower bound on the enrichment level of the samples.
The opposite ratio measures the noise level (lower is better.)

```{r avg.cpg.coverage}
{
 cat("Summed across", qc$nbams, "bams", "\n")
 cat("Average     CpG coverage:", qc$avg.cpg.coverage, "\n")
 cat("Average non-CpG coverage:", qc$avg.noncpg.coverage, "\n")
 cat("Enrichment ratio:", qc$avg.cpg.coverage / qc$avg.noncpg.coverage, "\n")
 cat("Noise level:", qc$avg.noncpg.coverage / qc$avg.cpg.coverage)
}
```

## Coverage vs. CpG density

Enrichment profiles are not only affected by the 
total amount of methylation of the DNA fragments,
which is a function of the number of CpGs and how much they are methylated, 
but also variability in the laboratory protocol. 
For example if the amount of MBD2 protein coated beads is too low 
highly methylated fragments will be overrepresented, 
and if the amount of protein is too high non-specific binding will occur. 
To capture such protocol variability, 
the The QC `measure avg.coverage.by.density` can be used to explore 
how average fragment coverage depends on CpG density. 
The The `qcmean` function returns the square root of the CpG density 
where maximum average CpG score is achieved. 
This `peak' sensitivity can be used as a lab technical covariate in 
downstream analyses to regress out 
variability in enrichment profiles across samples. 

```{r avg.coverage.by.density}
{
    cat("Highest coverage is observed at CpG density of",
        qcmean(qc$avg.coverage.by.density)^2)
    plot(qc$avg.coverage.by.density)
}
```

## Coverage around isolated CpGs

The distribution of reads around isolated CpGs 
(a site C for which the interval $[C-d,C+d]$ contains no other CpGs but $C$ 
where $d$ is the longest possible fragment size) 
also contains information about the enrichment profile. 
Because the total amount of methylation in fragments 
containing isolated CpGs is small, 
this distribution reflects the sensitivity of the enrichment.
That is, a sensitive assay would be characterized by a pattern where 
most reads start close to the isolated CpG. 
The read counts start to decrease further away from $C$ until 
they eventually stabilize to a "noise" level 
at distances larger than the maximum fragment size. 
This pattern of read counts around isolated CpGs 
also from the basis of the fragment size estimation needed 
to calculate CpG score for single end sequencing data.

The QC measure `hist.isolated.dist1` records the distribution of
distances from read start sites to isolated CpGs.
In our example, as we expected,
there are more reads starting closer to isolated CpGs.

```{r hist.isolated.dist1}
plot(qc$hist.isolated.dist1)
```

## Fraction of reads from chrX and chrY

The fractions of reads from chrX and chrY can be used to test whether
the individuals have the same sex as recorded in the phenotype data.
Mismatches often indicate swapped or mislabeled samples.
The first element of `qc$chrX.count` contains the number of chrX reads,
while `qcmean(qc$chrX.count)` gives the fraction of total. Same for chrY.


```{r chrXY}
{
 cat("ChrX reads: ", qc$chrX.count[1], ", which is ",
     qcmean(qc$chrX.count)*100, "% of total", sep="", "\n")
 cat("ChrY reads: ", qc$chrY.count[1], ", which is ",
     qcmean(qc$chrY.count)*100, "% of total", sep="", "\n")
}
```




